import matplotlibimport matplotlib.pyplot as plt # For plottingimport numpy as np # For arraysimport scipy.linalg as la # For linear algebra# a) og c) og e)def fwd_euler(yn, h, A): # y_(n+1) = (I + hA)y_n    """    Function for executing one time step of forward Euler.    INPUT:            yn (np.array): NumPy array of size 2 with current numerical solution.            h (float): time step size.            A (np.array): NumPy array of size 2x2, system matrix.    OUTPUT:            (np.array): NumPy array of size 2 with next numerical solution.    """    # Get size of system (even if we really know it should be two)    n = A.shape[0]    # Create Identity matrix    I = np.eye(n)    # Do a time step    return np.dot(I+h*A,yn)def bwd_euler(yn, h, A): # y_(n+1) = (I-hA)^(-1)y_n    """    Function for executing one time step of backward Euler.    INPUT:            yn (np.array): Current numerical solution.            h (float): time step size            A (np.array): System matrix.    OUTPUT:            (np.array): Next numerical solution."""    # Create identity matrix:    n = A.shape[0]    I = np.eye(n)    # We use SciPy's linear algebra package to invert matrix:    return la.solve(I-h*A,yn)def crank_nicolson(yn, h, A):    """    Function for executing one time step of Crank-Nicolson.    INPUT:           yn (np.array): Current numerical solution.           h (float): time step size           A (np.array): System matrix.    OUTPUT:            (np.array): Next numerical solution."""    # Create identity matrix:    n = A.shape[0]    I = np.eye(n)    # We use SciPy's linear algebra package to invert matrix:    return la.solve(I-0.5*h*A,np.dot(I+0.5*h*A, yn))# b) og d) og f)def simulate_fwd_euler(T,N,x0,A):    """    INPUT:        T (float): End time.        N (integer): Number of time steps.        x0 (np.array): NumPy array of size 2, initial condition.        A (np.array): NumPy array of size 2x2, system matrix.    OUTPUT:        y (np.array): NumPy array of size Nx2, numerical solution at each time step.    """    # Get time step size    h = T/N    # Initialize solution array    y = np.zeros((N,2), dtype=float)    y[0] = x0    # Do each time step:    for i in range(N-1):        # Execute fwd_euler from earlier        y[i+1] = fwd_euler(y[i], h, A) # Return solution array    return ydef simulate_bwd_euler(T,N,x0,A):    """    INPUT:        T (float): End time.        N (integer): Number of time steps.        x0 (np.array): NumPy array of size 2, initial condition.        A (np.array): NumPy array of size 2x2, system matrix.    OUTPUT:        y (np.array): NumPy array of size Nx2, numerical solution at each time step.    """    # Get time step size    h = T/N    # Initialize solution array    y = np.zeros((N,2), dtype=float)    y[0] = x0    # Do each time step:    for i in range(N-1):        # Execute fwd_euler from earlier        y[i+1] = bwd_euler(y[i], h, A) # Return solution array    return ydef simulate_crank_nicolson(T,N,x0,A):    """    INPUT:            T (float): End time.            N (integer): Number of time steps.            x0 (np.array): NumPy array of size 2, initial condition.            A (np.array): NumPy array of size 2x2, system matrix.    OUTPUT:           y (np.array): NumPy array of size Nx2, numerical solution at each time step.    """    # Get time step size    h = T/N    # Initialize solution array    y = np.zeros((N,2), dtype=float)    y[0] = x0    # Do each time step:    for i in range(N-1):        # Execute crank_nicolson from earlier        y[i+1] = crank_nicolson(y[i], h, A) # Return solution array    return y# ParametersT = 5.0 # End timeN = 100 # Number of time stepsA = np.array([[-5,4],[-2,1]], dtype=float) # System matrix  i)A2 = np.array([[0,2],[5,-3]], dtype=float) # System matrix ii)A3 = np.array([[1,9],[-2,-5]], dtype=float) # System matrix iii)# Generate initial conditions:theta = np.linspace(0.,2*np.pi, 5, endpoint=False) # 5 equidistributed angles from 0 tox01 = np.cos(theta) # x-coordinates for initial conditionsx02 = np.sin(theta) # y-coordinatesx0_arr = np.vstack( (x01, x02) ).T # Array containing each initial condition as rows.# Initialize figurefig = plt.figure()ax = fig.add_subplot(1,1,1)# Go through each initial condition:for x0 in x0_arr:    # Do a simulation with forward Euler    y = simulate_fwd_euler(T, N, x0, A3)    # Plot solution    ax.plot(y[:,0], y[:,1], 'b')    # Do a simulation with backward Euler:    y = simulate_bwd_euler(T, N, x0, A3)    ax.plot(y[:,0], y[:,1], 'r')    # Do a simulation with Crank-Nicolson:    y = simulate_crank_nicolson(T, N, x0, A3)    ax.plot(y[:,0], y[:,1], 'g')# Show plot:# Forward Euler are blue lines, Backward Euler are red lines# and Crank-Nicolson are green lines.plt.show()